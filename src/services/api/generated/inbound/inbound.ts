/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/vue-query';
import type {
  DataTag,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType
} from '@tanstack/vue-query';

import {
  computed,
  unref
} from 'vue';
import type {
  MaybeRef
} from 'vue';

import type {
  HTTPValidationError,
  InboundCreate,
  InboundRead,
  InboundUpdate
} from '.././schemas';

import { customFetch } from '../../custom-fetch';

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary List Inbound
 */
export type listInboundResponse200 = {
  data: InboundRead[]
  status: 200
}
    
export type listInboundResponseSuccess = (listInboundResponse200) & {
  headers: Headers;
};
;

export type listInboundResponse = (listInboundResponseSuccess)

export const getListInboundUrl = () => {


  

  return `/inbound/`
}

export const listInbound = async ( options?: RequestInit): Promise<listInboundResponse> => {
  
  return customFetch<listInboundResponse>(getListInboundUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getListInboundQueryKey = () => {
    return [
    'inbound'
    ] as const;
    }

    
export const getListInboundQueryOptions = <TData = Awaited<ReturnType<typeof listInbound>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listInbound>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  getListInboundQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listInbound>>> = ({ signal }) => listInbound({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listInbound>>, TError, TData> 
}

export type ListInboundQueryResult = NonNullable<Awaited<ReturnType<typeof listInbound>>>
export type ListInboundQueryError = unknown


/**
 * @summary List Inbound
 */

export function useListInbound<TData = Awaited<ReturnType<typeof listInbound>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listInbound>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListInboundQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}



/**
 * @summary Create Inbound
 */
export type createInboundResponse201 = {
  data: InboundRead
  status: 201
}

export type createInboundResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type createInboundResponseSuccess = (createInboundResponse201) & {
  headers: Headers;
};
export type createInboundResponseError = (createInboundResponse422) & {
  headers: Headers;
};

export type createInboundResponse = (createInboundResponseSuccess | createInboundResponseError)

export const getCreateInboundUrl = () => {


  

  return `/inbound/`
}

export const createInbound = async (inboundCreate: InboundCreate, options?: RequestInit): Promise<createInboundResponse> => {
  
  return customFetch<createInboundResponse>(getCreateInboundUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      inboundCreate,)
  }
);}




export const getCreateInboundMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createInbound>>, TError,{data: InboundCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createInbound>>, TError,{data: InboundCreate}, TContext> => {

const mutationKey = ['createInbound'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createInbound>>, {data: InboundCreate}> = (props) => {
          const {data} = props ?? {};

          return  createInbound(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateInboundMutationResult = NonNullable<Awaited<ReturnType<typeof createInbound>>>
    export type CreateInboundMutationBody = InboundCreate
    export type CreateInboundMutationError = HTTPValidationError

    /**
 * @summary Create Inbound
 */
export const useCreateInbound = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createInbound>>, TError,{data: InboundCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof createInbound>>,
        TError,
        {data: InboundCreate},
        TContext
      > => {

      const mutationOptions = getCreateInboundMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Get Inbound
 */
export type getInboundResponse200 = {
  data: InboundRead
  status: 200
}

export type getInboundResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getInboundResponseSuccess = (getInboundResponse200) & {
  headers: Headers;
};
export type getInboundResponseError = (getInboundResponse422) & {
  headers: Headers;
};

export type getInboundResponse = (getInboundResponseSuccess | getInboundResponseError)

export const getGetInboundUrl = (inboundId: number,) => {


  

  return `/inbound/${inboundId}`
}

export const getInbound = async (inboundId: number, options?: RequestInit): Promise<getInboundResponse> => {
  
  return customFetch<getInboundResponse>(getGetInboundUrl(inboundId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetInboundQueryKey = (inboundId?: MaybeRef<number>,) => {
    return [
    'inbound',inboundId
    ] as const;
    }

    
export const getGetInboundQueryOptions = <TData = Awaited<ReturnType<typeof getInbound>>, TError = HTTPValidationError>(inboundId: MaybeRef<number>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInbound>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  getGetInboundQueryKey(inboundId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getInbound>>> = ({ signal }) => getInbound(unref(inboundId), { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(inboundId))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getInbound>>, TError, TData> 
}

export type GetInboundQueryResult = NonNullable<Awaited<ReturnType<typeof getInbound>>>
export type GetInboundQueryError = HTTPValidationError


/**
 * @summary Get Inbound
 */

export function useGetInbound<TData = Awaited<ReturnType<typeof getInbound>>, TError = HTTPValidationError>(
 inboundId: MaybeRef<number>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInbound>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetInboundQueryOptions(inboundId,options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}



/**
 * @summary Update Inbound
 */
export type updateInboundResponse200 = {
  data: InboundRead
  status: 200
}

export type updateInboundResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type updateInboundResponseSuccess = (updateInboundResponse200) & {
  headers: Headers;
};
export type updateInboundResponseError = (updateInboundResponse422) & {
  headers: Headers;
};

export type updateInboundResponse = (updateInboundResponseSuccess | updateInboundResponseError)

export const getUpdateInboundUrl = (inboundId: number,) => {


  

  return `/inbound/${inboundId}`
}

export const updateInbound = async (inboundId: number,
    inboundUpdate: InboundUpdate, options?: RequestInit): Promise<updateInboundResponse> => {
  
  return customFetch<updateInboundResponse>(getUpdateInboundUrl(inboundId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      inboundUpdate,)
  }
);}




export const getUpdateInboundMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateInbound>>, TError,{inboundId: number;data: InboundUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updateInbound>>, TError,{inboundId: number;data: InboundUpdate}, TContext> => {

const mutationKey = ['updateInbound'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateInbound>>, {inboundId: number;data: InboundUpdate}> = (props) => {
          const {inboundId,data} = props ?? {};

          return  updateInbound(inboundId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateInboundMutationResult = NonNullable<Awaited<ReturnType<typeof updateInbound>>>
    export type UpdateInboundMutationBody = InboundUpdate
    export type UpdateInboundMutationError = HTTPValidationError

    /**
 * @summary Update Inbound
 */
export const useUpdateInbound = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateInbound>>, TError,{inboundId: number;data: InboundUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof updateInbound>>,
        TError,
        {inboundId: number;data: InboundUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateInboundMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Delete Inbound
 */
export type deleteInboundResponse204 = {
  data: void
  status: 204
}

export type deleteInboundResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type deleteInboundResponseSuccess = (deleteInboundResponse204) & {
  headers: Headers;
};
export type deleteInboundResponseError = (deleteInboundResponse422) & {
  headers: Headers;
};

export type deleteInboundResponse = (deleteInboundResponseSuccess | deleteInboundResponseError)

export const getDeleteInboundUrl = (inboundId: number,) => {


  

  return `/inbound/${inboundId}`
}

export const deleteInbound = async (inboundId: number, options?: RequestInit): Promise<deleteInboundResponse> => {
  
  return customFetch<deleteInboundResponse>(getDeleteInboundUrl(inboundId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteInboundMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteInbound>>, TError,{inboundId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteInbound>>, TError,{inboundId: number}, TContext> => {

const mutationKey = ['deleteInbound'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteInbound>>, {inboundId: number}> = (props) => {
          const {inboundId} = props ?? {};

          return  deleteInbound(inboundId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteInboundMutationResult = NonNullable<Awaited<ReturnType<typeof deleteInbound>>>
    
    export type DeleteInboundMutationError = HTTPValidationError

    /**
 * @summary Delete Inbound
 */
export const useDeleteInbound = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteInbound>>, TError,{inboundId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof deleteInbound>>,
        TError,
        {inboundId: number},
        TContext
      > => {

      const mutationOptions = getDeleteInboundMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    