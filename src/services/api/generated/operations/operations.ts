/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/vue-query';
import type {
  DataTag,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType
} from '@tanstack/vue-query';

import {
  computed,
  unref
} from 'vue';
import type {
  MaybeRef
} from 'vue';

import type {
  HTTPValidationError,
  OperationCreate,
  OperationRead,
  OperationUpdate
} from '.././schemas';

import { customFetch } from '../../custom-fetch';

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary List Operations
 */
export type listOperationsResponse200 = {
  data: OperationRead[]
  status: 200
}
    
export type listOperationsResponseSuccess = (listOperationsResponse200) & {
  headers: Headers;
};
;

export type listOperationsResponse = (listOperationsResponseSuccess)

export const getListOperationsUrl = () => {


  

  return `/operations/`
}

export const listOperations = async ( options?: RequestInit): Promise<listOperationsResponse> => {
  
  return customFetch<listOperationsResponse>(getListOperationsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getListOperationsQueryKey = () => {
    return [
    'operations'
    ] as const;
    }

    
export const getListOperationsQueryOptions = <TData = Awaited<ReturnType<typeof listOperations>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listOperations>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  getListOperationsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listOperations>>> = ({ signal }) => listOperations({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listOperations>>, TError, TData> 
}

export type ListOperationsQueryResult = NonNullable<Awaited<ReturnType<typeof listOperations>>>
export type ListOperationsQueryError = unknown


/**
 * @summary List Operations
 */

export function useListOperations<TData = Awaited<ReturnType<typeof listOperations>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listOperations>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListOperationsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}



/**
 * @summary Create Operation
 */
export type createOperationResponse201 = {
  data: OperationRead
  status: 201
}

export type createOperationResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type createOperationResponseSuccess = (createOperationResponse201) & {
  headers: Headers;
};
export type createOperationResponseError = (createOperationResponse422) & {
  headers: Headers;
};

export type createOperationResponse = (createOperationResponseSuccess | createOperationResponseError)

export const getCreateOperationUrl = () => {


  

  return `/operations/`
}

export const createOperation = async (operationCreate: OperationCreate, options?: RequestInit): Promise<createOperationResponse> => {
  
  return customFetch<createOperationResponse>(getCreateOperationUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      operationCreate,)
  }
);}




export const getCreateOperationMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOperation>>, TError,{data: OperationCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createOperation>>, TError,{data: OperationCreate}, TContext> => {

const mutationKey = ['createOperation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createOperation>>, {data: OperationCreate}> = (props) => {
          const {data} = props ?? {};

          return  createOperation(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateOperationMutationResult = NonNullable<Awaited<ReturnType<typeof createOperation>>>
    export type CreateOperationMutationBody = OperationCreate
    export type CreateOperationMutationError = HTTPValidationError

    /**
 * @summary Create Operation
 */
export const useCreateOperation = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOperation>>, TError,{data: OperationCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof createOperation>>,
        TError,
        {data: OperationCreate},
        TContext
      > => {

      const mutationOptions = getCreateOperationMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Get Operation
 */
export type getOperationResponse200 = {
  data: OperationRead
  status: 200
}

export type getOperationResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getOperationResponseSuccess = (getOperationResponse200) & {
  headers: Headers;
};
export type getOperationResponseError = (getOperationResponse422) & {
  headers: Headers;
};

export type getOperationResponse = (getOperationResponseSuccess | getOperationResponseError)

export const getGetOperationUrl = (operationId: number,) => {


  

  return `/operations/${operationId}`
}

export const getOperation = async (operationId: number, options?: RequestInit): Promise<getOperationResponse> => {
  
  return customFetch<getOperationResponse>(getGetOperationUrl(operationId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetOperationQueryKey = (operationId?: MaybeRef<number>,) => {
    return [
    'operations',operationId
    ] as const;
    }

    
export const getGetOperationQueryOptions = <TData = Awaited<ReturnType<typeof getOperation>>, TError = HTTPValidationError>(operationId: MaybeRef<number>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOperation>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  getGetOperationQueryKey(operationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOperation>>> = ({ signal }) => getOperation(unref(operationId), { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(operationId))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOperation>>, TError, TData> 
}

export type GetOperationQueryResult = NonNullable<Awaited<ReturnType<typeof getOperation>>>
export type GetOperationQueryError = HTTPValidationError


/**
 * @summary Get Operation
 */

export function useGetOperation<TData = Awaited<ReturnType<typeof getOperation>>, TError = HTTPValidationError>(
 operationId: MaybeRef<number>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOperation>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOperationQueryOptions(operationId,options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}



/**
 * @summary Update Operation
 */
export type updateOperationResponse200 = {
  data: OperationRead
  status: 200
}

export type updateOperationResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type updateOperationResponseSuccess = (updateOperationResponse200) & {
  headers: Headers;
};
export type updateOperationResponseError = (updateOperationResponse422) & {
  headers: Headers;
};

export type updateOperationResponse = (updateOperationResponseSuccess | updateOperationResponseError)

export const getUpdateOperationUrl = (operationId: number,) => {


  

  return `/operations/${operationId}`
}

export const updateOperation = async (operationId: number,
    operationUpdate: OperationUpdate, options?: RequestInit): Promise<updateOperationResponse> => {
  
  return customFetch<updateOperationResponse>(getUpdateOperationUrl(operationId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      operationUpdate,)
  }
);}




export const getUpdateOperationMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateOperation>>, TError,{operationId: number;data: OperationUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updateOperation>>, TError,{operationId: number;data: OperationUpdate}, TContext> => {

const mutationKey = ['updateOperation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateOperation>>, {operationId: number;data: OperationUpdate}> = (props) => {
          const {operationId,data} = props ?? {};

          return  updateOperation(operationId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateOperationMutationResult = NonNullable<Awaited<ReturnType<typeof updateOperation>>>
    export type UpdateOperationMutationBody = OperationUpdate
    export type UpdateOperationMutationError = HTTPValidationError

    /**
 * @summary Update Operation
 */
export const useUpdateOperation = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateOperation>>, TError,{operationId: number;data: OperationUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof updateOperation>>,
        TError,
        {operationId: number;data: OperationUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateOperationMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Delete Operation
 */
export type deleteOperationResponse204 = {
  data: void
  status: 204
}

export type deleteOperationResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type deleteOperationResponseSuccess = (deleteOperationResponse204) & {
  headers: Headers;
};
export type deleteOperationResponseError = (deleteOperationResponse422) & {
  headers: Headers;
};

export type deleteOperationResponse = (deleteOperationResponseSuccess | deleteOperationResponseError)

export const getDeleteOperationUrl = (operationId: number,) => {


  

  return `/operations/${operationId}`
}

export const deleteOperation = async (operationId: number, options?: RequestInit): Promise<deleteOperationResponse> => {
  
  return customFetch<deleteOperationResponse>(getDeleteOperationUrl(operationId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteOperationMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteOperation>>, TError,{operationId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteOperation>>, TError,{operationId: number}, TContext> => {

const mutationKey = ['deleteOperation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteOperation>>, {operationId: number}> = (props) => {
          const {operationId} = props ?? {};

          return  deleteOperation(operationId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteOperationMutationResult = NonNullable<Awaited<ReturnType<typeof deleteOperation>>>
    
    export type DeleteOperationMutationError = HTTPValidationError

    /**
 * @summary Delete Operation
 */
export const useDeleteOperation = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteOperation>>, TError,{operationId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof deleteOperation>>,
        TError,
        {operationId: number},
        TContext
      > => {

      const mutationOptions = getDeleteOperationMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    