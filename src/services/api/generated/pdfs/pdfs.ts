/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/vue-query';
import type {
  DataTag,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType
} from '@tanstack/vue-query';

import {
  computed,
  unref
} from 'vue';
import type {
  MaybeRef
} from 'vue';

import type {
  HTTPValidationError,
  InboundPDFCreate,
  OutboundPDFCreate,
  PurchaseOrderCreate
} from '.././schemas';

import { customFetch } from '../../custom-fetch';

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Genera un PDF de entrada al almac√©n a partir del inbound_id.
Busca autom√°ticamente todos los datos necesarios de la base de datos.

- **inbound_id**: ID del registro de inbound (requerido)

El sistema buscar√° autom√°ticamente:
- Datos del inbound (folio, fecha, transporte, etc.)
- Datos del proveedor (nombre)
- Todos los items (inbounddetails)
- Operations asociadas para vincular el PDF
 * @summary Generar y Descargar PDF de Entrada al Almac√©n
 */
export type generateInboundPDFResponse201 = {
  data: void
  status: 201
}

export type generateInboundPDFResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type generateInboundPDFResponseSuccess = (generateInboundPDFResponse201) & {
  headers: Headers;
};
export type generateInboundPDFResponseError = (generateInboundPDFResponse422) & {
  headers: Headers;
};

export type generateInboundPDFResponse = (generateInboundPDFResponseSuccess | generateInboundPDFResponseError)

export const getGenerateInboundPDFUrl = () => {


  

  return `/pdfs/inbound`
}

export const generateInboundPDF = async (inboundPDFCreate: InboundPDFCreate, options?: RequestInit): Promise<generateInboundPDFResponse> => {
  
  return customFetch<generateInboundPDFResponse>(getGenerateInboundPDFUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      inboundPDFCreate,)
  }
);}




export const getGenerateInboundPDFMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateInboundPDF>>, TError,{data: InboundPDFCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof generateInboundPDF>>, TError,{data: InboundPDFCreate}, TContext> => {

const mutationKey = ['generateInboundPDF'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof generateInboundPDF>>, {data: InboundPDFCreate}> = (props) => {
          const {data} = props ?? {};

          return  generateInboundPDF(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GenerateInboundPDFMutationResult = NonNullable<Awaited<ReturnType<typeof generateInboundPDF>>>
    export type GenerateInboundPDFMutationBody = InboundPDFCreate
    export type GenerateInboundPDFMutationError = HTTPValidationError

    /**
 * @summary Generar y Descargar PDF de Entrada al Almac√©n
 */
export const useGenerateInboundPDF = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateInboundPDF>>, TError,{data: InboundPDFCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof generateInboundPDF>>,
        TError,
        {data: InboundPDFCreate},
        TContext
      > => {

      const mutationOptions = getGenerateInboundPDFMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Descarga un PDF de entrada asociado a un inbound.

- **inbound_id**: ID del inbound
 * @summary Descargar PDF de Entrada por Inbound ID
 */
export type downloadInboundPDFResponse200 = {
  data: void
  status: 200
}

export type downloadInboundPDFResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type downloadInboundPDFResponseSuccess = (downloadInboundPDFResponse200) & {
  headers: Headers;
};
export type downloadInboundPDFResponseError = (downloadInboundPDFResponse422) & {
  headers: Headers;
};

export type downloadInboundPDFResponse = (downloadInboundPDFResponseSuccess | downloadInboundPDFResponseError)

export const getDownloadInboundPDFUrl = (inboundId: number,) => {


  

  return `/pdfs/inbound/${inboundId}`
}

export const downloadInboundPDF = async (inboundId: number, options?: RequestInit): Promise<downloadInboundPDFResponse> => {
  
  return customFetch<downloadInboundPDFResponse>(getDownloadInboundPDFUrl(inboundId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getDownloadInboundPDFQueryKey = (inboundId?: MaybeRef<number>,) => {
    return [
    'pdfs','inbound',inboundId
    ] as const;
    }

    
export const getDownloadInboundPDFQueryOptions = <TData = Awaited<ReturnType<typeof downloadInboundPDF>>, TError = HTTPValidationError>(inboundId: MaybeRef<number>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadInboundPDF>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  getDownloadInboundPDFQueryKey(inboundId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof downloadInboundPDF>>> = ({ signal }) => downloadInboundPDF(unref(inboundId), { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(inboundId))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof downloadInboundPDF>>, TError, TData> 
}

export type DownloadInboundPDFQueryResult = NonNullable<Awaited<ReturnType<typeof downloadInboundPDF>>>
export type DownloadInboundPDFQueryError = HTTPValidationError


/**
 * @summary Descargar PDF de Entrada por Inbound ID
 */

export function useDownloadInboundPDF<TData = Awaited<ReturnType<typeof downloadInboundPDF>>, TError = HTTPValidationError>(
 inboundId: MaybeRef<number>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadInboundPDF>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDownloadInboundPDFQueryOptions(inboundId,options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}



/**
 * Genera un PDF de orden de compra a partir del outbound_id.
Busca autom√°ticamente todos los datos necesarios de la base de datos.

- **outbound_id**: ID del registro de outbound (requerido)

El sistema buscar√° autom√°ticamente:
- Datos del outbound (folio como order_number, fecha, etc.)
- Datos del cliente/proveedor (nombre)
- Todos los items (outbounddetails)
- Operations asociadas para vincular el PDF
 * @summary Generar y Descargar PDF de Orden de Compra
 */
export type generatePurchaseOrderPDFResponse201 = {
  data: void
  status: 201
}

export type generatePurchaseOrderPDFResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type generatePurchaseOrderPDFResponseSuccess = (generatePurchaseOrderPDFResponse201) & {
  headers: Headers;
};
export type generatePurchaseOrderPDFResponseError = (generatePurchaseOrderPDFResponse422) & {
  headers: Headers;
};

export type generatePurchaseOrderPDFResponse = (generatePurchaseOrderPDFResponseSuccess | generatePurchaseOrderPDFResponseError)

export const getGeneratePurchaseOrderPDFUrl = () => {


  

  return `/pdfs/purchase-order`
}

export const generatePurchaseOrderPDF = async (purchaseOrderCreate: PurchaseOrderCreate, options?: RequestInit): Promise<generatePurchaseOrderPDFResponse> => {
  
  return customFetch<generatePurchaseOrderPDFResponse>(getGeneratePurchaseOrderPDFUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      purchaseOrderCreate,)
  }
);}




export const getGeneratePurchaseOrderPDFMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generatePurchaseOrderPDF>>, TError,{data: PurchaseOrderCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof generatePurchaseOrderPDF>>, TError,{data: PurchaseOrderCreate}, TContext> => {

const mutationKey = ['generatePurchaseOrderPDF'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof generatePurchaseOrderPDF>>, {data: PurchaseOrderCreate}> = (props) => {
          const {data} = props ?? {};

          return  generatePurchaseOrderPDF(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GeneratePurchaseOrderPDFMutationResult = NonNullable<Awaited<ReturnType<typeof generatePurchaseOrderPDF>>>
    export type GeneratePurchaseOrderPDFMutationBody = PurchaseOrderCreate
    export type GeneratePurchaseOrderPDFMutationError = HTTPValidationError

    /**
 * @summary Generar y Descargar PDF de Orden de Compra
 */
export const useGeneratePurchaseOrderPDF = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generatePurchaseOrderPDF>>, TError,{data: PurchaseOrderCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof generatePurchaseOrderPDF>>,
        TError,
        {data: PurchaseOrderCreate},
        TContext
      > => {

      const mutationOptions = getGeneratePurchaseOrderPDFMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Descarga un PDF de orden de compra asociado a un outbound.

- **outbound_id**: ID del outbound
 * @summary Descargar PDF de Orden de Compra por Outbound ID
 */
export type downloadPurchaseOrderPDFResponse200 = {
  data: void
  status: 200
}

export type downloadPurchaseOrderPDFResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type downloadPurchaseOrderPDFResponseSuccess = (downloadPurchaseOrderPDFResponse200) & {
  headers: Headers;
};
export type downloadPurchaseOrderPDFResponseError = (downloadPurchaseOrderPDFResponse422) & {
  headers: Headers;
};

export type downloadPurchaseOrderPDFResponse = (downloadPurchaseOrderPDFResponseSuccess | downloadPurchaseOrderPDFResponseError)

export const getDownloadPurchaseOrderPDFUrl = (outboundId: number,) => {


  

  return `/pdfs/purchase-order/${outboundId}`
}

export const downloadPurchaseOrderPDF = async (outboundId: number, options?: RequestInit): Promise<downloadPurchaseOrderPDFResponse> => {
  
  return customFetch<downloadPurchaseOrderPDFResponse>(getDownloadPurchaseOrderPDFUrl(outboundId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getDownloadPurchaseOrderPDFQueryKey = (outboundId?: MaybeRef<number>,) => {
    return [
    'pdfs','purchase-order',outboundId
    ] as const;
    }

    
export const getDownloadPurchaseOrderPDFQueryOptions = <TData = Awaited<ReturnType<typeof downloadPurchaseOrderPDF>>, TError = HTTPValidationError>(outboundId: MaybeRef<number>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadPurchaseOrderPDF>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  getDownloadPurchaseOrderPDFQueryKey(outboundId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof downloadPurchaseOrderPDF>>> = ({ signal }) => downloadPurchaseOrderPDF(unref(outboundId), { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(outboundId))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof downloadPurchaseOrderPDF>>, TError, TData> 
}

export type DownloadPurchaseOrderPDFQueryResult = NonNullable<Awaited<ReturnType<typeof downloadPurchaseOrderPDF>>>
export type DownloadPurchaseOrderPDFQueryError = HTTPValidationError


/**
 * @summary Descargar PDF de Orden de Compra por Outbound ID
 */

export function useDownloadPurchaseOrderPDF<TData = Awaited<ReturnType<typeof downloadPurchaseOrderPDF>>, TError = HTTPValidationError>(
 outboundId: MaybeRef<number>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadPurchaseOrderPDF>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDownloadPurchaseOrderPDFQueryOptions(outboundId,options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}



/**
 * Genera un PDF de salida del almac√©n a partir del outbound_id.
Busca autom√°ticamente todos los datos necesarios de la base de datos.

- **outbound_id**: ID del registro de outbound (requerido)

El sistema buscar√° autom√°ticamente:
- Datos del outbound (folio, fecha, transporte, etc.)
- Datos del cliente/proveedor (nombre)
- Todos los items (outbounddetails)
- Operations asociadas para vincular el PDF
 * @summary Generar y Descargar PDF de Salida del Almac√©n
 */
export type generateOutboundPDFResponse201 = {
  data: void
  status: 201
}

export type generateOutboundPDFResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type generateOutboundPDFResponseSuccess = (generateOutboundPDFResponse201) & {
  headers: Headers;
};
export type generateOutboundPDFResponseError = (generateOutboundPDFResponse422) & {
  headers: Headers;
};

export type generateOutboundPDFResponse = (generateOutboundPDFResponseSuccess | generateOutboundPDFResponseError)

export const getGenerateOutboundPDFUrl = () => {


  

  return `/pdfs/outbound`
}

export const generateOutboundPDF = async (outboundPDFCreate: OutboundPDFCreate, options?: RequestInit): Promise<generateOutboundPDFResponse> => {
  
  return customFetch<generateOutboundPDFResponse>(getGenerateOutboundPDFUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      outboundPDFCreate,)
  }
);}




export const getGenerateOutboundPDFMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateOutboundPDF>>, TError,{data: OutboundPDFCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof generateOutboundPDF>>, TError,{data: OutboundPDFCreate}, TContext> => {

const mutationKey = ['generateOutboundPDF'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof generateOutboundPDF>>, {data: OutboundPDFCreate}> = (props) => {
          const {data} = props ?? {};

          return  generateOutboundPDF(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GenerateOutboundPDFMutationResult = NonNullable<Awaited<ReturnType<typeof generateOutboundPDF>>>
    export type GenerateOutboundPDFMutationBody = OutboundPDFCreate
    export type GenerateOutboundPDFMutationError = HTTPValidationError

    /**
 * @summary Generar y Descargar PDF de Salida del Almac√©n
 */
export const useGenerateOutboundPDF = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateOutboundPDF>>, TError,{data: OutboundPDFCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof generateOutboundPDF>>,
        TError,
        {data: OutboundPDFCreate},
        TContext
      > => {

      const mutationOptions = getGenerateOutboundPDFMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Descarga un PDF de salida asociado a un outbound.

- **outbound_id**: ID del outbound
 * @summary Descargar PDF de Salida por Outbound ID
 */
export type downloadOutboundPDFResponse200 = {
  data: void
  status: 200
}

export type downloadOutboundPDFResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type downloadOutboundPDFResponseSuccess = (downloadOutboundPDFResponse200) & {
  headers: Headers;
};
export type downloadOutboundPDFResponseError = (downloadOutboundPDFResponse422) & {
  headers: Headers;
};

export type downloadOutboundPDFResponse = (downloadOutboundPDFResponseSuccess | downloadOutboundPDFResponseError)

export const getDownloadOutboundPDFUrl = (outboundId: number,) => {


  

  return `/pdfs/outbound/${outboundId}`
}

export const downloadOutboundPDF = async (outboundId: number, options?: RequestInit): Promise<downloadOutboundPDFResponse> => {
  
  return customFetch<downloadOutboundPDFResponse>(getDownloadOutboundPDFUrl(outboundId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getDownloadOutboundPDFQueryKey = (outboundId?: MaybeRef<number>,) => {
    return [
    'pdfs','outbound',outboundId
    ] as const;
    }

    
export const getDownloadOutboundPDFQueryOptions = <TData = Awaited<ReturnType<typeof downloadOutboundPDF>>, TError = HTTPValidationError>(outboundId: MaybeRef<number>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadOutboundPDF>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  getDownloadOutboundPDFQueryKey(outboundId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof downloadOutboundPDF>>> = ({ signal }) => downloadOutboundPDF(unref(outboundId), { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(outboundId))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof downloadOutboundPDF>>, TError, TData> 
}

export type DownloadOutboundPDFQueryResult = NonNullable<Awaited<ReturnType<typeof downloadOutboundPDF>>>
export type DownloadOutboundPDFQueryError = HTTPValidationError


/**
 * @summary Descargar PDF de Salida por Outbound ID
 */

export function useDownloadOutboundPDF<TData = Awaited<ReturnType<typeof downloadOutboundPDF>>, TError = HTTPValidationError>(
 outboundId: MaybeRef<number>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadOutboundPDF>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDownloadOutboundPDFQueryOptions(outboundId,options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}



