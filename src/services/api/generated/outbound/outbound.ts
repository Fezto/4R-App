/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/vue-query';
import type {
  DataTag,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType
} from '@tanstack/vue-query';

import {
  computed,
  unref
} from 'vue';
import type {
  MaybeRef
} from 'vue';

import type {
  HTTPValidationError,
  OutboundCreate,
  OutboundRead,
  OutboundUpdate
} from '.././schemas';

import { customFetch } from '../../custom-fetch';

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary List Outbound
 */
export type listOutboundResponse200 = {
  data: OutboundRead[]
  status: 200
}
    
export type listOutboundResponseSuccess = (listOutboundResponse200) & {
  headers: Headers;
};
;

export type listOutboundResponse = (listOutboundResponseSuccess)

export const getListOutboundUrl = () => {


  

  return `/outbound/`
}

export const listOutbound = async ( options?: RequestInit): Promise<listOutboundResponse> => {
  
  return customFetch<listOutboundResponse>(getListOutboundUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getListOutboundQueryKey = () => {
    return [
    'outbound'
    ] as const;
    }

    
export const getListOutboundQueryOptions = <TData = Awaited<ReturnType<typeof listOutbound>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listOutbound>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  getListOutboundQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listOutbound>>> = ({ signal }) => listOutbound({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listOutbound>>, TError, TData> 
}

export type ListOutboundQueryResult = NonNullable<Awaited<ReturnType<typeof listOutbound>>>
export type ListOutboundQueryError = unknown


/**
 * @summary List Outbound
 */

export function useListOutbound<TData = Awaited<ReturnType<typeof listOutbound>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listOutbound>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListOutboundQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}



/**
 * @summary Create Outbound
 */
export type createOutboundResponse201 = {
  data: OutboundRead
  status: 201
}

export type createOutboundResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type createOutboundResponseSuccess = (createOutboundResponse201) & {
  headers: Headers;
};
export type createOutboundResponseError = (createOutboundResponse422) & {
  headers: Headers;
};

export type createOutboundResponse = (createOutboundResponseSuccess | createOutboundResponseError)

export const getCreateOutboundUrl = () => {


  

  return `/outbound/`
}

export const createOutbound = async (outboundCreate: OutboundCreate, options?: RequestInit): Promise<createOutboundResponse> => {
  
  return customFetch<createOutboundResponse>(getCreateOutboundUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      outboundCreate,)
  }
);}




export const getCreateOutboundMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOutbound>>, TError,{data: OutboundCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createOutbound>>, TError,{data: OutboundCreate}, TContext> => {

const mutationKey = ['createOutbound'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createOutbound>>, {data: OutboundCreate}> = (props) => {
          const {data} = props ?? {};

          return  createOutbound(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateOutboundMutationResult = NonNullable<Awaited<ReturnType<typeof createOutbound>>>
    export type CreateOutboundMutationBody = OutboundCreate
    export type CreateOutboundMutationError = HTTPValidationError

    /**
 * @summary Create Outbound
 */
export const useCreateOutbound = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOutbound>>, TError,{data: OutboundCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof createOutbound>>,
        TError,
        {data: OutboundCreate},
        TContext
      > => {

      const mutationOptions = getCreateOutboundMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Get Outbound
 */
export type getOutboundResponse200 = {
  data: OutboundRead
  status: 200
}

export type getOutboundResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getOutboundResponseSuccess = (getOutboundResponse200) & {
  headers: Headers;
};
export type getOutboundResponseError = (getOutboundResponse422) & {
  headers: Headers;
};

export type getOutboundResponse = (getOutboundResponseSuccess | getOutboundResponseError)

export const getGetOutboundUrl = (outboundId: number,) => {


  

  return `/outbound/${outboundId}`
}

export const getOutbound = async (outboundId: number, options?: RequestInit): Promise<getOutboundResponse> => {
  
  return customFetch<getOutboundResponse>(getGetOutboundUrl(outboundId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetOutboundQueryKey = (outboundId?: MaybeRef<number>,) => {
    return [
    'outbound',outboundId
    ] as const;
    }

    
export const getGetOutboundQueryOptions = <TData = Awaited<ReturnType<typeof getOutbound>>, TError = HTTPValidationError>(outboundId: MaybeRef<number>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOutbound>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  getGetOutboundQueryKey(outboundId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOutbound>>> = ({ signal }) => getOutbound(unref(outboundId), { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(outboundId))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOutbound>>, TError, TData> 
}

export type GetOutboundQueryResult = NonNullable<Awaited<ReturnType<typeof getOutbound>>>
export type GetOutboundQueryError = HTTPValidationError


/**
 * @summary Get Outbound
 */

export function useGetOutbound<TData = Awaited<ReturnType<typeof getOutbound>>, TError = HTTPValidationError>(
 outboundId: MaybeRef<number>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOutbound>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOutboundQueryOptions(outboundId,options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}



/**
 * @summary Update Outbound
 */
export type updateOutboundResponse200 = {
  data: OutboundRead
  status: 200
}

export type updateOutboundResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type updateOutboundResponseSuccess = (updateOutboundResponse200) & {
  headers: Headers;
};
export type updateOutboundResponseError = (updateOutboundResponse422) & {
  headers: Headers;
};

export type updateOutboundResponse = (updateOutboundResponseSuccess | updateOutboundResponseError)

export const getUpdateOutboundUrl = (outboundId: number,) => {


  

  return `/outbound/${outboundId}`
}

export const updateOutbound = async (outboundId: number,
    outboundUpdate: OutboundUpdate, options?: RequestInit): Promise<updateOutboundResponse> => {
  
  return customFetch<updateOutboundResponse>(getUpdateOutboundUrl(outboundId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      outboundUpdate,)
  }
);}




export const getUpdateOutboundMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateOutbound>>, TError,{outboundId: number;data: OutboundUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updateOutbound>>, TError,{outboundId: number;data: OutboundUpdate}, TContext> => {

const mutationKey = ['updateOutbound'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateOutbound>>, {outboundId: number;data: OutboundUpdate}> = (props) => {
          const {outboundId,data} = props ?? {};

          return  updateOutbound(outboundId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateOutboundMutationResult = NonNullable<Awaited<ReturnType<typeof updateOutbound>>>
    export type UpdateOutboundMutationBody = OutboundUpdate
    export type UpdateOutboundMutationError = HTTPValidationError

    /**
 * @summary Update Outbound
 */
export const useUpdateOutbound = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateOutbound>>, TError,{outboundId: number;data: OutboundUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof updateOutbound>>,
        TError,
        {outboundId: number;data: OutboundUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateOutboundMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Delete Outbound
 */
export type deleteOutboundResponse204 = {
  data: void
  status: 204
}

export type deleteOutboundResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type deleteOutboundResponseSuccess = (deleteOutboundResponse204) & {
  headers: Headers;
};
export type deleteOutboundResponseError = (deleteOutboundResponse422) & {
  headers: Headers;
};

export type deleteOutboundResponse = (deleteOutboundResponseSuccess | deleteOutboundResponseError)

export const getDeleteOutboundUrl = (outboundId: number,) => {


  

  return `/outbound/${outboundId}`
}

export const deleteOutbound = async (outboundId: number, options?: RequestInit): Promise<deleteOutboundResponse> => {
  
  return customFetch<deleteOutboundResponse>(getDeleteOutboundUrl(outboundId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteOutboundMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteOutbound>>, TError,{outboundId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteOutbound>>, TError,{outboundId: number}, TContext> => {

const mutationKey = ['deleteOutbound'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteOutbound>>, {outboundId: number}> = (props) => {
          const {outboundId} = props ?? {};

          return  deleteOutbound(outboundId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteOutboundMutationResult = NonNullable<Awaited<ReturnType<typeof deleteOutbound>>>
    
    export type DeleteOutboundMutationError = HTTPValidationError

    /**
 * @summary Delete Outbound
 */
export const useDeleteOutbound = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteOutbound>>, TError,{outboundId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof deleteOutbound>>,
        TError,
        {outboundId: number},
        TContext
      > => {

      const mutationOptions = getDeleteOutboundMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    