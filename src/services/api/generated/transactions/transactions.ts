/**
 * Generated by orval v7.13.2 游꽄
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation
} from '@tanstack/vue-query';
import type {
  MutationFunction,
  QueryClient,
  UseMutationOptions,
  UseMutationReturnType
} from '@tanstack/vue-query';

import type {
  HTTPValidationError,
  InboundTransactionCreate,
  InboundTransactionResponse,
  OutboundTransactionCreate,
  OutboundTransactionResponse
} from '.././schemas';

import { customFetch } from '../../custom-fetch';

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Crea una entrada completa al almac칠n en una sola transacci칩n:

1. Crea el registro de Inbound
2. Por cada item:
   - Crea una Operation (tipo inbound)
   - Crea un InboundDetail vinculado al inbound y operation
   - Suma el peso (quantity) al campo weight del Inventory
3. Genera el PDF autom치ticamente (opcional)

**Beneficios:**
- Todo en una sola transacci칩n (rollback autom치tico si algo falla)
- Una sola llamada HTTP desde el frontend
- PDF generado autom치ticamente
- Validaciones de negocio centralizadas
- Actualizaci칩n autom치tica del peso en inventario

**Request Body:**
```json
{
  "transporter": "company",
  "license_plate": "ABC-123",
  "folio": "E-2024-001",
  "ticket_number": "T-12345",
  "movement_date": "2024-11-05",
  "supplier_id": 1,
  "observations": "Entrada urgente",
  "authorized_by": "Juan P칠rez",
  "received_by": "Mar칤a L칩pez",
  "items": [
    {
      "inventory_id": 1,
      "product_name_snapshot": "Aluminio reciclado",
      "quantity": 500.5,
      "unit_snapshot": "kg",
      "unit_price": 45.00,
      "total_amount": 22522.50,
      "supplier_id": 1,
      "invoice_folio": "FAC-001",
      "payment_form_code": "_99"
    }
  ],
  "generate_pdf": true
}
```
 * @summary Crear Entrada Completa (Inbound + Details + Operations + PDF)
 */
export type createCompleteInboundResponse201 = {
  data: InboundTransactionResponse
  status: 201
}

export type createCompleteInboundResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type createCompleteInboundResponseSuccess = (createCompleteInboundResponse201) & {
  headers: Headers;
};
export type createCompleteInboundResponseError = (createCompleteInboundResponse422) & {
  headers: Headers;
};

export type createCompleteInboundResponse = (createCompleteInboundResponseSuccess | createCompleteInboundResponseError)

export const getCreateCompleteInboundUrl = () => {


  

  return `/transactions/inbound/complete`
}

export const createCompleteInbound = async (inboundTransactionCreate: InboundTransactionCreate, options?: RequestInit): Promise<createCompleteInboundResponse> => {
  
  return customFetch<createCompleteInboundResponse>(getCreateCompleteInboundUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      inboundTransactionCreate,)
  }
);}




export const getCreateCompleteInboundMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCompleteInbound>>, TError,{data: InboundTransactionCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createCompleteInbound>>, TError,{data: InboundTransactionCreate}, TContext> => {

const mutationKey = ['createCompleteInbound'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCompleteInbound>>, {data: InboundTransactionCreate}> = (props) => {
          const {data} = props ?? {};

          return  createCompleteInbound(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCompleteInboundMutationResult = NonNullable<Awaited<ReturnType<typeof createCompleteInbound>>>
    export type CreateCompleteInboundMutationBody = InboundTransactionCreate
    export type CreateCompleteInboundMutationError = HTTPValidationError

    /**
 * @summary Crear Entrada Completa (Inbound + Details + Operations + PDF)
 */
export const useCreateCompleteInbound = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCompleteInbound>>, TError,{data: InboundTransactionCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof createCompleteInbound>>,
        TError,
        {data: InboundTransactionCreate},
        TContext
      > => {

      const mutationOptions = getCreateCompleteInboundMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Crea una salida completa del almac칠n en una sola transacci칩n:

1. Valida que hay peso suficiente en inventario
2. Crea el registro de Outbound
3. Por cada item:
   - Crea una Operation (tipo outbound)
   - Crea un OutboundDetail vinculado al outbound y operation
   - Resta el peso (quantity) del campo weight del Inventory
4. Genera el PDF de salida autom치ticamente (opcional)
5. Genera la orden de compra autom치ticamente (opcional)

**Beneficios:**
- Todo en una sola transacci칩n (rollback autom치tico si algo falla)
- Una sola llamada HTTP desde el frontend
- PDFs generados autom치ticamente
- Validaci칩n de peso disponible antes de crear la salida
- Actualizaci칩n autom치tica del peso en inventario
 * @summary Crear Salida Completa (Outbound + Details + Operations + PDFs)
 */
export type createCompleteOutboundResponse201 = {
  data: OutboundTransactionResponse
  status: 201
}

export type createCompleteOutboundResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type createCompleteOutboundResponseSuccess = (createCompleteOutboundResponse201) & {
  headers: Headers;
};
export type createCompleteOutboundResponseError = (createCompleteOutboundResponse422) & {
  headers: Headers;
};

export type createCompleteOutboundResponse = (createCompleteOutboundResponseSuccess | createCompleteOutboundResponseError)

export const getCreateCompleteOutboundUrl = () => {


  

  return `/transactions/outbound/complete`
}

export const createCompleteOutbound = async (outboundTransactionCreate: OutboundTransactionCreate, options?: RequestInit): Promise<createCompleteOutboundResponse> => {
  
  return customFetch<createCompleteOutboundResponse>(getCreateCompleteOutboundUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      outboundTransactionCreate,)
  }
);}




export const getCreateCompleteOutboundMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCompleteOutbound>>, TError,{data: OutboundTransactionCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createCompleteOutbound>>, TError,{data: OutboundTransactionCreate}, TContext> => {

const mutationKey = ['createCompleteOutbound'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCompleteOutbound>>, {data: OutboundTransactionCreate}> = (props) => {
          const {data} = props ?? {};

          return  createCompleteOutbound(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCompleteOutboundMutationResult = NonNullable<Awaited<ReturnType<typeof createCompleteOutbound>>>
    export type CreateCompleteOutboundMutationBody = OutboundTransactionCreate
    export type CreateCompleteOutboundMutationError = HTTPValidationError

    /**
 * @summary Crear Salida Completa (Outbound + Details + Operations + PDFs)
 */
export const useCreateCompleteOutbound = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCompleteOutbound>>, TError,{data: OutboundTransactionCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof createCompleteOutbound>>,
        TError,
        {data: OutboundTransactionCreate},
        TContext
      > => {

      const mutationOptions = getCreateCompleteOutboundMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    